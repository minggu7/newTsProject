프론트 기본 세팅 다 하고나서.

먼저 받을 타입 세팅 하기

types 폴더에 board.ts 파일 생성

그다음 api 관련해서 모아놓은 api.ts

그다음 프론트 페이지 구조 짜고.

-------------------------서버연동 express------------------------------
이제 서버 연결

cd backend
npm install express cors helmet morgan dotenv
	- express 는 서버 프레임워크고
	- cors: 다른곳에서 자원 가져오는 경우 커팅
 	- helmet: 서버 보안상 취약점 보완
	- dotenv: 외부에 공유하지않기위해 특별하게 값들 저장해놓고 자유롭게 쓸 수 있게함
	- morgan: 요청과 응답에 대한 정보를 콘솔에 추가적으로 찍음

그다음 개발 의존성으로 설치
npm install -D @types/express @types/cors @types/morgan @types/node nodemon ts-node
최적화 목적


진행순서

0. 환경설정
1. 서버 구동 확인 → 기본 동작 확인
2. API 테스트 → 프론트엔드 연동 확인
3. DB 연결 → 실제 데이터로 확장
4. PM2 → 나중에 배포할 때



날짜변환 함수 어디에 넣어놓고 재사용하기.

DB에 계정 만들어놓고.
--SELECT grantee, table_schema, table_name, privilege_type
--FROM information_schema.role_table_grants
--WHERE grantee = 'kmg2388';
-- GRANT ALL PRIVILEGES ON TABLE news_details TO kmg2388;

스키마도 따로 만들었음. myboard.(현재 테이블 X)


이제 backend 폴더에서 아래 명려어 실행
- npm install pg(포ㅓ스트그레)
- npm install -D @types/pg(개발 단계에서 사용)

express 요청, 응답 구조
.get('/posts', async (require, res) => {......
첫 번째 매개변수: 요청받을 URL 경로
두 번째 매개변수: 요청/응답 객체를 받는 함수.

async는?? 함수 내부에서 비동기 작업(await)쓸 수 있게 해줌
데이터 요청 후 다 받으면 다음 로직 진행하려고.


-----------------express에서 넘어온 데이터 가공하는법--------------------

1. url 형식으로 넘어온 값(GET)
Ex) axios.get('/posts?id=6&page=2) 이렇게 넘겨주면
    app.get('/posts', (req, res) => {
    const id = req.query.id; // "6"
    const page = req.query.page; // "2"
});

req.query.value 형태로 받음


2. 비동기 요청으로 넘어온 값(POST)
Ex) axios.post('/posts', {
       title: '제목',
       content: '내용',
       author: '작성자'
});
이렇게 넘겨주면

app.post('/posts', (req, res) => {
      const title = req.body.title;
      const content = req.body.content;
      const author = req.body.author;
});

req.body.value 형태로 받음

--------------------게시글에서 가장 중요한 재귀함수--------------------
`
                    WITH RECURSIVE board_tree AS (
                      SELECT
                        my_board_pk,
                        my_board_title,
                        my_board_author,
                        my_board_content,
                        my_board_create_at,
                        my_board_update_at,
                        my_board_view_count,
                        my_board_parent_pk,
                        1 AS depth,
                        CAST(my_board_pk AS TEXT) AS path
                      FROM myboard.myboard
                      WHERE my_board_parent_pk IS NULL
              
                      UNION ALL
              
                      SELECT
                        c.my_board_pk,
                        c.my_board_title,
                        c.my_board_author,
                        c.my_board_content,
                        c.my_board_create_at,
                        c.my_board_update_at,
                        c.my_board_view_count,
                        c.my_board_parent_pk,
                        p.depth + 1 AS depth,
                        p.path || '>' || c.my_board_pk AS path
                      FROM myboard.myboard c
                      JOIN board_tree p ON c.my_board_parent_pk::int = p.my_board_pk
                    )
                    SELECT *
                    FROM board_tree
                    ORDER BY path
                    LIMIT $1 OFFSET $2
                    `,
                    [limit, offset]
                  );


잘 보면 > 를 사용해서 path 로 재귀 구조 나타냄.
일치하면 id기준으로 새겨지는거
1 > 5 > 7
그리고 path 기준으로 ASC 했으니?

1 > 5 > 7
1 > 5 > 4
1 > 8 > 1
10 > 3> 7 이런식이면

1 이 가장 먼저오고 그다음 5 그다음 7 그다음 4
그러니까 1 > 5 > 4 가 가장 먼저 옴. 그다음 뭐 1 > 5 > 4 이런식으로
동일한 깊이에 대해서 가장 높은 숫자가 먼저옴

날짜 함수 공통으로 만들고 사용해서 날짜 형변환.

그 후에는 로그인부터 쭉.

다시 게시판쪽 오면 첨부파일 넣기.

구조분해 할당 중요.
name 값과 value값만 받아서
[name] : value 로 name으로 설정된 속성값 : 해당 값. 으로 컨트롤

    const [form, setForm] = useState<signUpType>({
        userId: '',
        userPassword: ''
    });

타입 파일 임포트 후 (signUpType) 저렇게 사용.

데이터 체크만 하고 확인하는 경우(유무 확인)
 count 보다는 exists로 하자

쿼리바인딩이 중요(포스트그레)
$1 하면 첫번째 파라미터임
const result =await db.query(
            `
                SELECT 1
                FROM myuser
                WHERE userId = $1
            `,
            [userInputId]
        );

이렇게 , [userInputId]로

React.FormEvent는 "React에서 form 관련 이벤트가 발생할 때 전달되는 객체의 타입"입니다.
이 객체를 통해
기본 동작 막기 (e.preventDefault())
이벤트가 발생한 요소 정보 접근 (e.target)
기타 이벤트 관련 정보 활용

뭐가  어디서 form 작동시켰는지 받아주는놈이라 생각하면 됨


또다른 구조분해 할당 구문 있음
const response = await api.post(`/userSignUp`, form);
  const { status, message } = response.data;
  return { status, message };

이런식으로 response에 있는 status, message 빼오기

회원가입 후 아이디 영역 disabled, 

시큐리티랑 jwt먼저
이거 하고 게시판 내부로 고고.
첨부파일 속성 추가(게시글 DB), 첨부파일 테이블 추가
글 작성부터


//인증 인가 구현. jwt 구현

백엔드에 패키지 설정
PS C:\Users\WINITECH\Desktop\타입스 예제 만들어보기> cd backend
PS C:\Users\WINITECH\Desktop\타입스 예제 만들어보기\backend> npm install jsonwebtoken bcryptjs
npm install -D @types/jsonwebtoken @types/bcryptjs


이제 하나씩 보자.
가장 위에부터

먼저 import 부분이다.
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

그 다음 .env 파일에서 환경설정한 값을 가져와서 사용해도 좋고 임시 비밀키 내가 만들어도 좋다.

//JWT 설정
const JWT_SECRET = process.env.JWT_SECRET || `아무거나`;
const JWT_EXPIRES_IN = '24h;//유효시간

//jwt 토큰 생성
const generateToken = (userId: string): string => {
	return jwt.sign({ userId }, JWT_SECRET, {expiresIn: JWT_EXPIRES_IN});// 사용할(저장) 값(현재는 userId만), 비밀키, 유효시간을 매개변수로 사용
}

//JWT 토큰 검증.
const verifyToken = (token: string) : any => {
	try{
		return jwt.verify(token, JWT_SECRET);// 아까 사용한 비밀키 그대로 사용해서 복호화 후 확인
	} catch(error){
		return null;
	}
}

//이건 비밀번호 해싱(솔트값 줘서 무작위로 암호화)
const hashPassword = async (password:string): Promise<string> => {
	const saltRounds = 10;
	return await bcrypt.hash(password, saltRounds);
}

//비밀번호 검증
const comparePassword = async (password: string, hashedPassword: string): Promise<boolean> => {
	return await bcrypt.compare(password, hashedPassword);
}

//인증 미들웨어





먼저 이해하자
클라이언트가 서버에 요청을 보낼 때, 사용자의 인증 상태를 나타내기 위해 HTTP의 Authorization 헤더에 Bearer 토큰이 포함

Authorization 헤더는 HTTP 프로토콜에서 클라이언트가 서버에 인가된 상태임을 전달하는 수단으로 사용됩니다. 이는 사용자 인증을 거친 후, 서버에 자신의 신원을 증명하기 위해 필수적입니다. 일반적으로 다음과 같은 구조를 가집니다.

Authorization: <스키마> <자격 증명>
여기서 <스키마>는 인증 방식(예: Basic, Bearer)을 나타내고, <자격 증명>은 클라이언트의 인증 정보를 포함합니다. Bearer는 이러한 인증 방식


다 하고나서 INSERt문들에 채번 진행 후 마저진행

--------------------------------------------------------------------------토큰기본설정완료--------------------------------------------------------------------
스테이트리스(무상태성) 리프레시 로테이트 형식으로 구현함

위 방식으로 쭉 진행하기위해서는 추가적인 작업 몇 개 필요함

0. 로그아웃 시 토큰 반납(access 와 refreshtoken 둘 다)
	> ts 파일 먼저 설정. 받아야 하는 값은? 리프레시 토큰 값이랑 userId?? 
		> api 요청 부분 구현
			> 서버 코드 구현(쿼리)
				>반환값은 status와 message로(완)
1. 만약 토큰 가지고 있는 상태로 url접속(흔히 크롬 자동완성 rul이나 뒤;로가기, 즐겨찾기 등) 시 검증 후 로그인 하지않고 사용하게 해줘야함
2. 토큰 재발급. AccessToken 만료 시 1. 먼저 RefreshToken 여부 확인하고 RefreshToken 있으면 검증 하지않고 새로 발급.
			           2. RefreshToken없으면? 똑같이 검증 후 access 토큰과 refresh토큰 재발급
3. 라우트마다 인증/인가 설정.(SpringSecurity에서 한것처럼 url마다 지정) (굳이 구현 X)
4. 자동 로그인 유지(이게 2번하고 같은거 아닌가?)



















































































































